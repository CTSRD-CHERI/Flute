//
// Generated by Bluespec Compiler, version 2019.05.beta2 (build a88bf40db, 2019-05-24)
//
//
//
//
// Ports:
// Name                         I/O  size props
// RDY_req                        O     1 const
// RDY_start                      O     1 const
// result_fst                     O     1 reg
// RDY_result_fst                 O     1
// result_snd_fst                 O    64 reg
// RDY_result_snd_fst             O     1
// result_snd_snd                 O    64 reg
// RDY_result_snd_snd             O     1
// mmio_client_request_get        O   131 reg
// RDY_mmio_client_request_get    O     1 reg
// RDY_mmio_client_response_put   O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// req_mmu_cache_req              I   208 reg
// start_pa                       I    64 reg
// mmio_client_response_put       I    65 reg
// EN_req                         I     1
// EN_start                       I     1
// EN_mmio_client_response_put    I     1
// EN_mmio_client_request_get     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMMIO(CLK,
	      RST_N,

	      req_mmu_cache_req,
	      EN_req,
	      RDY_req,

	      start_pa,
	      EN_start,
	      RDY_start,

	      result_fst,
	      RDY_result_fst,

	      result_snd_fst,
	      RDY_result_snd_fst,

	      result_snd_snd,
	      RDY_result_snd_snd,

	      EN_mmio_client_request_get,
	      mmio_client_request_get,
	      RDY_mmio_client_request_get,

	      mmio_client_response_put,
	      EN_mmio_client_response_put,
	      RDY_mmio_client_response_put);
  parameter [2 : 0] verbosity = 3'b0;
  input  CLK;
  input  RST_N;

  // action method req
  input  [207 : 0] req_mmu_cache_req;
  input  EN_req;
  output RDY_req;

  // action method start
  input  [63 : 0] start_pa;
  input  EN_start;
  output RDY_start;

  // value method result_fst
  output result_fst;
  output RDY_result_fst;

  // value method result_snd_fst
  output [63 : 0] result_snd_fst;
  output RDY_result_snd_fst;

  // value method result_snd_snd
  output [63 : 0] result_snd_snd;
  output RDY_result_snd_snd;

  // actionvalue method mmio_client_request_get
  input  EN_mmio_client_request_get;
  output [130 : 0] mmio_client_request_get;
  output RDY_mmio_client_request_get;

  // action method mmio_client_response_put
  input  [64 : 0] mmio_client_response_put;
  input  EN_mmio_client_response_put;
  output RDY_mmio_client_response_put;

  // signals for module outputs
  wire [130 : 0] mmio_client_request_get;
  wire [63 : 0] result_snd_fst, result_snd_snd;
  wire RDY_mmio_client_request_get,
       RDY_mmio_client_response_put,
       RDY_req,
       RDY_result_fst,
       RDY_result_snd_fst,
       RDY_result_snd_snd,
       RDY_start,
       result_fst;

  // register rg_err
  reg rg_err;
  wire rg_err$D_IN, rg_err$EN;

  // register rg_final_st_val
  reg [63 : 0] rg_final_st_val;
  wire [63 : 0] rg_final_st_val$D_IN;
  wire rg_final_st_val$EN;

  // register rg_fsm_state
  reg [1 : 0] rg_fsm_state;
  reg [1 : 0] rg_fsm_state$D_IN;
  wire rg_fsm_state$EN;

  // register rg_ld_val
  reg [63 : 0] rg_ld_val;
  wire [63 : 0] rg_ld_val$D_IN;
  wire rg_ld_val$EN;

  // register rg_pa
  reg [63 : 0] rg_pa;
  wire [63 : 0] rg_pa$D_IN;
  wire rg_pa$EN;

  // register rg_req
  reg [207 : 0] rg_req;
  wire [207 : 0] rg_req$D_IN;
  wire rg_req$EN;

  // ports of submodule f_single_reqs
  reg [130 : 0] f_single_reqs$D_IN;
  wire [130 : 0] f_single_reqs$D_OUT;
  wire f_single_reqs$CLR,
       f_single_reqs$DEQ,
       f_single_reqs$EMPTY_N,
       f_single_reqs$ENQ,
       f_single_reqs$FULL_N;

  // ports of submodule f_single_rsps
  wire [64 : 0] f_single_rsps$D_IN, f_single_rsps$D_OUT;
  wire f_single_rsps$CLR,
       f_single_rsps$DEQ,
       f_single_rsps$EMPTY_N,
       f_single_rsps$ENQ,
       f_single_rsps$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_AMO_SC,
       CAN_FIRE_RL_rl_read_req,
       CAN_FIRE_RL_rl_read_rsp,
       CAN_FIRE_RL_rl_write_req,
       CAN_FIRE_mmio_client_request_get,
       CAN_FIRE_mmio_client_response_put,
       CAN_FIRE_req,
       CAN_FIRE_start,
       WILL_FIRE_RL_rl_AMO_SC,
       WILL_FIRE_RL_rl_read_req,
       WILL_FIRE_RL_rl_read_rsp,
       WILL_FIRE_RL_rl_write_req,
       WILL_FIRE_mmio_client_request_get,
       WILL_FIRE_mmio_client_response_put,
       WILL_FIRE_req,
       WILL_FIRE_start;

  // inputs to muxes for submodule ports
  wire [130 : 0] MUX_f_single_reqs$enq_1__VAL_1,
		 MUX_f_single_reqs$enq_1__VAL_2,
		 MUX_f_single_reqs$enq_1__VAL_3;
  wire [63 : 0] MUX_rg_ld_val$write_1__VAL_1;
  wire MUX_f_single_reqs$enq_1__SEL_1, MUX_rg_ld_val$write_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] v__h569;
  reg [31 : 0] v__h800;
  reg [31 : 0] v__h2026;
  reg [31 : 0] v__h2308;
  reg [31 : 0] v__h563;
  reg [31 : 0] v__h794;
  reg [31 : 0] v__h2020;
  reg [31 : 0] v__h2302;
  // synopsys translate_on

  // remaining internal signals
  reg [63 : 0] _theResult_____2__h1509, mask__h1052, y__h1305;
  reg CASE_rg_req_BITS_204_TO_203_0b0_f_single_rsps_ETC__q2;
  wire [63 : 0] IF_rg_req_BITS_204_TO_203_6_EQ_0b10_1_THEN_SEX_ETC___d85,
		final_ld_val__h1445,
		final_st_val__h1446,
		final_st_val__h1533,
		final_st_val__h1623,
		final_st_val__h1700,
		final_st_val__h1704,
		final_st_val__h1708,
		final_st_val__h1712,
		final_st_val__h1717,
		final_st_val__h1723,
		final_st_val__h1728,
		ld_val__h1032,
		result__h1293,
		result__h1365,
		w1___1__h1592,
		w1__h1502,
		w2___1__h1593,
		w2__h1504;
  wire [31 : 0] f_single_rspsD_OUT_BITS_31_TO_0__q1,
		rg_req_BITS_106_TO_75__q3;
  wire f_single_rsps_first__7_BIT_64_8_AND_NOT_rg_req_ETC___d122;

  // action method req
  assign RDY_req = 1'd1 ;
  assign CAN_FIRE_req = 1'd1 ;
  assign WILL_FIRE_req = EN_req ;

  // action method start
  assign RDY_start = 1'd1 ;
  assign CAN_FIRE_start = 1'd1 ;
  assign WILL_FIRE_start = EN_start ;

  // value method result_fst
  assign result_fst = rg_err ;
  assign RDY_result_fst = rg_fsm_state == 2'd0 ;

  // value method result_snd_fst
  assign result_snd_fst = rg_ld_val ;
  assign RDY_result_snd_fst = rg_fsm_state == 2'd0 ;

  // value method result_snd_snd
  assign result_snd_snd = rg_final_st_val ;
  assign RDY_result_snd_snd = rg_fsm_state == 2'd0 ;

  // actionvalue method mmio_client_request_get
  assign mmio_client_request_get = f_single_reqs$D_OUT ;
  assign RDY_mmio_client_request_get = f_single_reqs$EMPTY_N ;
  assign CAN_FIRE_mmio_client_request_get = f_single_reqs$EMPTY_N ;
  assign WILL_FIRE_mmio_client_request_get = EN_mmio_client_request_get ;

  // action method mmio_client_response_put
  assign RDY_mmio_client_response_put = f_single_rsps$FULL_N ;
  assign CAN_FIRE_mmio_client_response_put = f_single_rsps$FULL_N ;
  assign WILL_FIRE_mmio_client_response_put = EN_mmio_client_response_put ;

  // submodule f_single_reqs
  FIFO2 #(.width(32'd131), .guarded(32'd1)) f_single_reqs(.RST(RST_N),
							  .CLK(CLK),
							  .D_IN(f_single_reqs$D_IN),
							  .ENQ(f_single_reqs$ENQ),
							  .DEQ(f_single_reqs$DEQ),
							  .CLR(f_single_reqs$CLR),
							  .D_OUT(f_single_reqs$D_OUT),
							  .FULL_N(f_single_reqs$FULL_N),
							  .EMPTY_N(f_single_reqs$EMPTY_N));

  // submodule f_single_rsps
  FIFO2 #(.width(32'd65), .guarded(32'd1)) f_single_rsps(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(f_single_rsps$D_IN),
							 .ENQ(f_single_rsps$ENQ),
							 .DEQ(f_single_rsps$DEQ),
							 .CLR(f_single_rsps$CLR),
							 .D_OUT(f_single_rsps$D_OUT),
							 .FULL_N(f_single_rsps$FULL_N),
							 .EMPTY_N(f_single_rsps$EMPTY_N));

  // rule RL_rl_read_req
  assign CAN_FIRE_RL_rl_read_req =
	     f_single_reqs$FULL_N && rg_fsm_state == 2'd1 &&
	     rg_req[207:206] != 2'd1 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00011) ;
  assign WILL_FIRE_RL_rl_read_req = CAN_FIRE_RL_rl_read_req ;

  // rule RL_rl_read_rsp
  assign CAN_FIRE_RL_rl_read_rsp =
	     f_single_rsps$EMPTY_N &&
	     (!f_single_rsps$D_OUT[64] || rg_req[207:206] == 2'd0 ||
	      rg_req[207:206] == 2'd2 && rg_req[74:70] == 5'b00010 ||
	      f_single_reqs$FULL_N) &&
	     rg_fsm_state == 2'd2 ;
  assign WILL_FIRE_RL_rl_read_rsp = CAN_FIRE_RL_rl_read_rsp ;

  // rule RL_rl_write_req
  assign CAN_FIRE_RL_rl_write_req =
	     f_single_reqs$FULL_N && rg_fsm_state == 2'd1 &&
	     rg_req[207:206] == 2'd1 ;
  assign WILL_FIRE_RL_rl_write_req = CAN_FIRE_RL_rl_write_req ;

  // rule RL_rl_AMO_SC
  assign CAN_FIRE_RL_rl_AMO_SC =
	     rg_fsm_state == 2'd1 && rg_req[207:206] == 2'd2 &&
	     rg_req[74:70] == 5'b00011 ;
  assign WILL_FIRE_RL_rl_AMO_SC = CAN_FIRE_RL_rl_AMO_SC ;

  // inputs to muxes for submodule ports
  assign MUX_f_single_reqs$enq_1__SEL_1 =
	     WILL_FIRE_RL_rl_read_rsp && f_single_rsps$D_OUT[64] &&
	     rg_req[207:206] != 2'd0 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00010) ;
  assign MUX_rg_ld_val$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_read_rsp && f_single_rsps$D_OUT[64] ;
  assign MUX_f_single_reqs$enq_1__VAL_1 =
	     { 1'd0, rg_pa, rg_req[204:203], final_st_val__h1446 } ;
  assign MUX_f_single_reqs$enq_1__VAL_2 = { 1'd1, rg_pa, rg_req[204:139] } ;
  assign MUX_f_single_reqs$enq_1__VAL_3 =
	     { 1'd0, rg_pa, rg_req[204:203], rg_req[138:75] } ;
  assign MUX_rg_ld_val$write_1__VAL_1 =
	     (rg_req[207:206] == 2'd0 ||
	      rg_req[207:206] == 2'd2 && rg_req[74:70] == 5'b00010) ?
	       ld_val__h1032 :
	       final_ld_val__h1445 ;

  // register rg_err
  assign rg_err$D_IN = !EN_req ;
  assign rg_err$EN =
	     WILL_FIRE_RL_rl_read_rsp && !f_single_rsps$D_OUT[64] || EN_req ;

  // register rg_final_st_val
  assign rg_final_st_val$D_IN =
	     MUX_f_single_reqs$enq_1__SEL_1 ?
	       final_st_val__h1446 :
	       rg_req[138:75] ;
  assign rg_final_st_val$EN =
	     WILL_FIRE_RL_rl_read_rsp && f_single_rsps$D_OUT[64] &&
	     rg_req[207:206] != 2'd0 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00010) ||
	     WILL_FIRE_RL_rl_write_req ;

  // register rg_fsm_state
  always@(EN_start or
	  WILL_FIRE_RL_rl_AMO_SC or
	  WILL_FIRE_RL_rl_write_req or
	  WILL_FIRE_RL_rl_read_rsp or WILL_FIRE_RL_rl_read_req)
  case (1'b1)
    EN_start: rg_fsm_state$D_IN = 2'd1;
    WILL_FIRE_RL_rl_AMO_SC || WILL_FIRE_RL_rl_write_req ||
    WILL_FIRE_RL_rl_read_rsp:
	rg_fsm_state$D_IN = 2'd0;
    WILL_FIRE_RL_rl_read_req: rg_fsm_state$D_IN = 2'd2;
    default: rg_fsm_state$D_IN = 2'b10 /* unspecified value */ ;
  endcase
  assign rg_fsm_state$EN =
	     WILL_FIRE_RL_rl_AMO_SC || WILL_FIRE_RL_rl_write_req ||
	     WILL_FIRE_RL_rl_read_rsp ||
	     EN_start ||
	     WILL_FIRE_RL_rl_read_req ;

  // register rg_ld_val
  assign rg_ld_val$D_IN =
	     MUX_rg_ld_val$write_1__SEL_1 ?
	       MUX_rg_ld_val$write_1__VAL_1 :
	       64'd1 ;
  assign rg_ld_val$EN =
	     WILL_FIRE_RL_rl_read_rsp && f_single_rsps$D_OUT[64] ||
	     WILL_FIRE_RL_rl_AMO_SC ;

  // register rg_pa
  assign rg_pa$D_IN = start_pa ;
  assign rg_pa$EN = EN_start ;

  // register rg_req
  assign rg_req$D_IN = req_mmu_cache_req ;
  assign rg_req$EN = EN_req ;

  // submodule f_single_reqs
  always@(MUX_f_single_reqs$enq_1__SEL_1 or
	  MUX_f_single_reqs$enq_1__VAL_1 or
	  WILL_FIRE_RL_rl_read_req or
	  MUX_f_single_reqs$enq_1__VAL_2 or
	  WILL_FIRE_RL_rl_write_req or MUX_f_single_reqs$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_f_single_reqs$enq_1__SEL_1:
	  f_single_reqs$D_IN = MUX_f_single_reqs$enq_1__VAL_1;
      WILL_FIRE_RL_rl_read_req:
	  f_single_reqs$D_IN = MUX_f_single_reqs$enq_1__VAL_2;
      WILL_FIRE_RL_rl_write_req:
	  f_single_reqs$D_IN = MUX_f_single_reqs$enq_1__VAL_3;
      default: f_single_reqs$D_IN =
		   131'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign f_single_reqs$ENQ =
	     WILL_FIRE_RL_rl_read_rsp && f_single_rsps$D_OUT[64] &&
	     rg_req[207:206] != 2'd0 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00010) ||
	     WILL_FIRE_RL_rl_read_req ||
	     WILL_FIRE_RL_rl_write_req ;
  assign f_single_reqs$DEQ = EN_mmio_client_request_get ;
  assign f_single_reqs$CLR = 1'b0 ;

  // submodule f_single_rsps
  assign f_single_rsps$D_IN = mmio_client_response_put ;
  assign f_single_rsps$ENQ = EN_mmio_client_response_put ;
  assign f_single_rsps$DEQ = CAN_FIRE_RL_rl_read_rsp ;
  assign f_single_rsps$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_rg_req_BITS_204_TO_203_6_EQ_0b10_1_THEN_SEX_ETC___d85 =
	     (rg_req[204:203] == 2'b10) ?
	       { {32{rg_req_BITS_106_TO_75__q3[31]}},
		 rg_req_BITS_106_TO_75__q3 } :
	       rg_req[138:75] ;
  assign f_single_rspsD_OUT_BITS_31_TO_0__q1 = f_single_rsps$D_OUT[31:0] ;
  assign f_single_rsps_first__7_BIT_64_8_AND_NOT_rg_req_ETC___d122 =
	     f_single_rsps$D_OUT[64] && rg_req[207:206] != 2'd0 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00010) &&
	     verbosity != 3'd0 ;
  assign final_ld_val__h1445 =
	     (rg_req[204:203] == 2'b10) ?
	       { {32{f_single_rspsD_OUT_BITS_31_TO_0__q1[31]}},
		 f_single_rspsD_OUT_BITS_31_TO_0__q1 } :
	       f_single_rsps$D_OUT[63:0] ;
  assign final_st_val__h1446 =
	     (rg_req[204:203] == 2'b10) ?
	       final_st_val__h1533 :
	       _theResult_____2__h1509 ;
  assign final_st_val__h1533 = { 32'd0, _theResult_____2__h1509[31:0] } ;
  assign final_st_val__h1623 =
	     final_ld_val__h1445 +
	     IF_rg_req_BITS_204_TO_203_6_EQ_0b10_1_THEN_SEX_ETC___d85 ;
  assign final_st_val__h1700 = w1__h1502 ^ w2__h1504 ;
  assign final_st_val__h1704 = w1__h1502 & w2__h1504 ;
  assign final_st_val__h1708 = w1__h1502 | w2__h1504 ;
  assign final_st_val__h1712 =
	     (w1__h1502 < w2__h1504) ? w1__h1502 : w2__h1504 ;
  assign final_st_val__h1717 =
	     (w1__h1502 <= w2__h1504) ? w2__h1504 : w1__h1502 ;
  assign final_st_val__h1723 =
	     ((final_ld_val__h1445 ^ 64'h8000000000000000) <
	      (IF_rg_req_BITS_204_TO_203_6_EQ_0b10_1_THEN_SEX_ETC___d85 ^
	       64'h8000000000000000)) ?
	       w1__h1502 :
	       w2__h1504 ;
  assign final_st_val__h1728 =
	     ((final_ld_val__h1445 ^ 64'h8000000000000000) <=
	      (IF_rg_req_BITS_204_TO_203_6_EQ_0b10_1_THEN_SEX_ETC___d85 ^
	       64'h8000000000000000)) ?
	       w2__h1504 :
	       w1__h1502 ;
  assign ld_val__h1032 =
	     (!rg_req[205] &&
	      CASE_rg_req_BITS_204_TO_203_0b0_f_single_rsps_ETC__q2) ?
	       result__h1293 :
	       result__h1365 ;
  assign result__h1293 = f_single_rsps$D_OUT[63:0] | y__h1305 ;
  assign result__h1365 = f_single_rsps$D_OUT[63:0] & mask__h1052 ;
  assign rg_req_BITS_106_TO_75__q3 = rg_req[106:75] ;
  assign w1___1__h1592 = { 32'd0, f_single_rsps$D_OUT[31:0] } ;
  assign w1__h1502 =
	     (rg_req[204:203] == 2'b10) ?
	       w1___1__h1592 :
	       f_single_rsps$D_OUT[63:0] ;
  assign w2___1__h1593 = { 32'd0, rg_req[106:75] } ;
  assign w2__h1504 =
	     (rg_req[204:203] == 2'b10) ? w2___1__h1593 : rg_req[138:75] ;
  always@(rg_req)
  begin
    case (rg_req[204:203])
      2'b0: mask__h1052 = 64'h00000000000000FF;
      2'b01: mask__h1052 = 64'h000000000000FFFF;
      2'b10: mask__h1052 = 64'h00000000FFFFFFFF;
      2'd3: mask__h1052 = 64'hFFFFFFFFFFFFFFFF;
    endcase
  end
  always@(rg_req)
  begin
    case (rg_req[204:203])
      2'b0: y__h1305 = 64'hFFFFFFFFFFFFFF00;
      2'b01: y__h1305 = 64'hFFFFFFFFFFFF0000;
      2'b10: y__h1305 = 64'hFFFFFFFF00000000;
      2'd3: y__h1305 = 64'd0;
    endcase
  end
  always@(rg_req or f_single_rsps$D_OUT)
  begin
    case (rg_req[204:203])
      2'b0:
	  CASE_rg_req_BITS_204_TO_203_0b0_f_single_rsps_ETC__q2 =
	      f_single_rsps$D_OUT[7];
      2'b01:
	  CASE_rg_req_BITS_204_TO_203_0b0_f_single_rsps_ETC__q2 =
	      f_single_rsps$D_OUT[15];
      2'b10:
	  CASE_rg_req_BITS_204_TO_203_0b0_f_single_rsps_ETC__q2 =
	      f_single_rsps$D_OUT[31];
      2'd3:
	  CASE_rg_req_BITS_204_TO_203_0b0_f_single_rsps_ETC__q2 =
	      f_single_rsps$D_OUT[63];
    endcase
  end
  always@(rg_req or
	  final_st_val__h1728 or
	  final_st_val__h1623 or
	  w2__h1504 or
	  final_st_val__h1700 or
	  final_st_val__h1708 or
	  final_st_val__h1704 or
	  final_st_val__h1723 or final_st_val__h1712 or final_st_val__h1717)
  begin
    case (rg_req[74:70])
      5'b0: _theResult_____2__h1509 = final_st_val__h1623;
      5'b00001: _theResult_____2__h1509 = w2__h1504;
      5'b00100: _theResult_____2__h1509 = final_st_val__h1700;
      5'b01000: _theResult_____2__h1509 = final_st_val__h1708;
      5'b01100: _theResult_____2__h1509 = final_st_val__h1704;
      5'b10000: _theResult_____2__h1509 = final_st_val__h1723;
      5'b11000: _theResult_____2__h1509 = final_st_val__h1712;
      5'b11100: _theResult_____2__h1509 = final_st_val__h1717;
      default: _theResult_____2__h1509 = final_st_val__h1728;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_err <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_final_st_val <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_fsm_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_ld_val <= `BSV_ASSIGNMENT_DELAY 64'd0;
      end
    else
      begin
        if (rg_err$EN) rg_err <= `BSV_ASSIGNMENT_DELAY rg_err$D_IN;
	if (rg_final_st_val$EN)
	  rg_final_st_val <= `BSV_ASSIGNMENT_DELAY rg_final_st_val$D_IN;
	if (rg_fsm_state$EN)
	  rg_fsm_state <= `BSV_ASSIGNMENT_DELAY rg_fsm_state$D_IN;
	if (rg_ld_val$EN) rg_ld_val <= `BSV_ASSIGNMENT_DELAY rg_ld_val$D_IN;
      end
    if (rg_pa$EN) rg_pa <= `BSV_ASSIGNMENT_DELAY rg_pa$D_IN;
    if (rg_req$EN) rg_req <= `BSV_ASSIGNMENT_DELAY rg_req$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_err = 1'h0;
    rg_final_st_val = 64'hAAAAAAAAAAAAAAAA;
    rg_fsm_state = 2'h2;
    rg_ld_val = 64'hAAAAAAAAAAAAAAAA;
    rg_pa = 64'hAAAAAAAAAAAAAAAA;
    rg_req = 208'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_req && verbosity != 3'd0)
	begin
	  v__h569 = $stime;
	  #0;
	end
    v__h563 = v__h569 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_req && verbosity != 3'd0)
	$display("%0d: %m.rl_read_req: f3 %0h vaddr %0h  paddr %0h",
		 v__h563,
		 rg_req[205:203],
		 rg_req[202:139],
		 rg_pa);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0)
	begin
	  v__h800 = $stime;
	  #0;
	end
    v__h794 = v__h800 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0)
	$display("%0d: %m.rl_read_rsp: vaddr %0h  paddr %0h",
		 v__h794,
		 rg_req[202:139],
		 rg_pa);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0) $write("    ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0)
	$write("Single_Rsp { ", "ok: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0 &&
	  f_single_rsps$D_OUT[64])
	$write("True");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0 &&
	  !f_single_rsps$D_OUT[64])
	$write("False");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0)
	$write(", ", "data: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0)
	$write("'h%h", f_single_rsps$D_OUT[63:0], " }");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && verbosity != 3'd0) $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && f_single_rsps$D_OUT[64] &&
	  (rg_req[207:206] == 2'd0 ||
	   rg_req[207:206] == 2'd2 && rg_req[74:70] == 5'b00010) &&
	  verbosity != 3'd0)
	$display("    Load or LR: f3 %0h ld_val %0h",
		 rg_req[205:203],
		 ld_val__h1032);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp &&
	  f_single_rsps_first__7_BIT_64_8_AND_NOT_rg_req_ETC___d122)
	$display("    AMO: f3 %0d  f7 %0h  ld_val %0h st_val %0h",
		 rg_req[205:203],
		 rg_req[74:68],
		 f_single_rsps$D_OUT[63:0],
		 rg_req[138:75]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp &&
	  f_single_rsps_first__7_BIT_64_8_AND_NOT_rg_req_ETC___d122)
	$display("    => final_ld_val %0h final_st_val %0h",
		 final_ld_val__h1445,
		 final_st_val__h1446);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_read_rsp && !f_single_rsps$D_OUT[64] &&
	  verbosity != 3'd0)
	$display("    MEM_RSP_ERR");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_req && verbosity != 3'd0)
	begin
	  v__h2026 = $stime;
	  #0;
	end
    v__h2020 = v__h2026 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_req && verbosity != 3'd0)
	$display("%0d: %m.rl_write_req; f3 %0h  vaddr %0h  paddr %0h  word64 %0h",
		 v__h2020,
		 rg_req[205:203],
		 rg_req[202:139],
		 rg_pa,
		 rg_req[138:75]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_req && verbosity >= 3'd2)
	$display("    goto MMIO_DONE");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_AMO_SC && verbosity != 3'd0)
	begin
	  v__h2308 = $stime;
	  #0;
	end
    v__h2302 = v__h2308 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_AMO_SC && verbosity != 3'd0)
	$display("%0d: %m.rl_AMO_SC; f3 %0h  vaddr %0h  paddr %0h  st_value %0h",
		 v__h2302,
		 rg_req[205:203],
		 rg_req[202:139],
		 rg_pa,
		 rg_req[138:75]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_AMO_SC && verbosity != 3'd0)
	$display("    FAIL due to I/O address.");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_AMO_SC && verbosity != 3'd0)
	$display("    goto MMIO_DONE");
  end
  // synopsys translate_on
endmodule  // mkMMIO


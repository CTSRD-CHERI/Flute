mkdir -p build_dir
INFO: Re-generating CHERI tag controller parameters
../libs/TagController/tagsparams.py -v -c 128 -s 0 64 -a 32 --covered-start-addr 0xc0000000 --covered-mem-size 0x3fffc000 --top-addr 0xfffff000 -b ../src_SSITH_P2/src_BSV/TagTableStructure.bsv
Deriving tags configuration from parameters:
covered_mem_size = 1073725440 bytes
cap_size = 128 bits
top_addr = 0xfffff000
addr_align = 32 bytes (5 addr bottom bits to ignore)
structure = [0, 64]
--------------------------------------------------------------------------------
lvls = [{0xff7ff080, 8388480 bytes}, {0xff7df080, 131070 bytes}]
last_addr = 0xff7df07f
tags_size = 8519552 bytes
--------------------------------------------------------------------------------
generating Bluespec MultiLevelTagLookup module import configuration file ../src_SSITH_P2/src_BSV/TagTableStructure.bsv
INFO: Re-generated CHERI tag controller parameters
INFO: Generating RTL into Verilog_RTL ...
bsc -u -elab -verilog  -vdir Verilog_RTL  -bdir build_dir  -info-dir build_dir  -D RV64 -D SV39 -D RISCV -D CAP128 -D MEM64 -D RISCV -D ISA_CHERI -D ISA_PRIV_M  -D ISA_PRIV_S  -D ISA_PRIV_U -D ISA_I  -D ISA_M  -D ISA_A  -D ISA_C -D ISA_F -D ISA_D -D ISA_FD_DIV -D ISA_FD -D ISA_F_OR_D -D SHIFT_BARREL -D MULT_SERIAL -D Near_Mem_Caches -D FABRIC64 -D INCLUDE_GDB_CONTROL -D BRVF_TRACE -D XILINX_BSCAN  -D XILINX_XCVU9P  -D JTAG_TAP -keep-fires -aggressive-conditions -no-warn-action-shadowing -no-show-timestamps -suppress-warnings G0020 +RTS -K128M -RTS  -show-range-conflict  -p :../src_Core/CPU:../src_Core/ISA:../src_Core/RegFiles:../src_Core/Core:../src_Core/Near_Mem_VM:../src_Core/PLIC:../src_Core/Near_Mem_IO:../src_Core/Debug_Module:../src_Core/BSV_Additional_Libs:../src_SSITH_P2/src_BSV::../libs/BlueStuff/AXI:../libs/BlueStuff/BlueBasics:../libs/BlueStuff::../libs/cheri-cap-lib:../libs/TagController/TagController:../libs/TagController/TagController/CacheCore:../libs/BlueStuff/BlueUtils:+  src_BSV/P2_Core.bsv
checking package dependencies
compiling ../src_Core/BSV_Additional_Libs/GetPut_Aux.bsv
compiling ../src_Core/BSV_Additional_Libs/Semi_FIFOF.bsv
compiling ../libs/BlueStuff/Routable.bsv
compiling ../libs/cheri-cap-lib/CHERICap.bsv
compiling ../libs/cheri-cap-lib/CHERICC_Fat.bsv
Warning: "../libs/cheri-cap-lib/CHERICC_Fat.bsv", line 881, column 10: (T0127)
  Exporting orphan typeclass instance CHERICap::CHERICap#(Bit#(129), 18, 1,
  64, 128, 11). The instance's typeclass as well as all of the instance's
  source type parameters are defined in other packages. This can lead to
  confusing and inconsistent instance resolution if the orphan instance is not
  imported everywhere it could be used.
compiling ../src_Core/BSV_Additional_Libs/Cur_Cycle.bsv
compiling ../libs/BlueStuff/BlueBasics/SourceSink.bsv
compiling ../src_Core/Debug_Module/DM_Common.bsv
compiling ../src_Core/Debug_Module/DM_CPU_Req_Rsp.bsv
compiling ../libs/TagController/TagController/CacheCore/VnD.bsv
compiling ../src_Core/ISA/ISA_Decls.bsv
compiling ../src_Core/Debug_Module/DM_Run_Control.bsv
code generation for mkDM_Run_Control starts
Warning: "../src_Core/Debug_Module/DM_Run_Control.bsv", line 56, column 8: (G0036)
  Rule "rl_hart0_reset_rsp" will appear to fire before "rl_hart0_run_rsp" when
  both fire in the same clock cycle, affecting:
    calls to rg_hart0_running.write vs. rg_hart0_running.write
Warning: "../src_Core/Debug_Module/DM_Run_Control.bsv", line 56, column 8: (G0036)
  Rule "rl_hart0_reset_rsp" will appear to fire before "rl_ndm_reset_rsp" when
  both fire in the same clock cycle, affecting:
    calls to rg_hart0_running.write vs. rg_hart0_running.write
Verilog file created: Verilog_RTL/mkDM_Run_Control.v
Elaborated module file created: build_dir/mkDM_Run_Control.ba
compiling ../src_Core/Debug_Module/DM_Abstract_Commands.bsv
code generation for mkDM_Abstract_Commands starts
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "write" will appear to fire before "rl_unknown_read_start" when both
  fire in the same clock cycle, affecting:
    calls to
      rg_start_reg_access.write vs. rg_start_reg_access.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "reset" will appear to fire before "rl_unknown_read_start" when both
  fire in the same clock cycle, affecting:
    calls to
      rg_start_reg_access.write vs. rg_start_reg_access.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "write" will appear to fire before "rl_unknown_write_start" when both
  fire in the same clock cycle, affecting:
    calls to
      rg_start_reg_access.write vs. rg_start_reg_access.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "reset" will appear to fire before "rl_unknown_write_start" when both
  fire in the same clock cycle, affecting:
    calls to
      rg_start_reg_access.write vs. rg_start_reg_access.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "write" will appear to fire before "rl_fpr_read_finish" when both fire
  in the same clock cycle, affecting:
    calls to
      rg_data0.write vs. rg_data0.write
      rg_data1.write vs. rg_data1.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "reset" will appear to fire before "rl_fpr_read_finish" when both fire
  in the same clock cycle, affecting:
    calls to
      rg_data0.write vs. rg_data0.write
      rg_data1.write vs. rg_data1.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "write" will appear to fire before "rl_fpr_read_start" when both fire
  in the same clock cycle, affecting:
    calls to rg_start_reg_access.write vs. rg_start_reg_access.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "write" will appear to fire before "rl_fpr_write_finish" when both fire
  in the same clock cycle, affecting:
    calls to
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "reset" will appear to fire before "rl_fpr_write_finish" when both fire
  in the same clock cycle, affecting:
    calls to
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "reset" will appear to fire before "write" when both fire in the same
  clock cycle, affecting:
    calls to
      rg_start_reg_access.write vs. rg_start_reg_access.write
      rg_data0.write vs. rg_data0.write
      rg_data1.write vs. rg_data1.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
      rg_command_access_reg_write.write vs. rg_command_access_reg_write.write
      rg_command_access_reg_regno.write vs. rg_command_access_reg_regno.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "rl_gpr_read_finish" will appear to fire before "write" when both fire
  in the same clock cycle, affecting:
    calls to
      rg_data0.write vs. rg_data0.write
      rg_data1.write vs. rg_data1.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "rl_gpr_read_start" will appear to fire before "write" when both fire
  in the same clock cycle, affecting:
    calls to rg_start_reg_access.write vs. rg_start_reg_access.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "rl_gpr_write_finish" will appear to fire before "write" when both fire
  in the same clock cycle, affecting:
    calls to
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "rl_csr_read_finish" will appear to fire before "write" when both fire
  in the same clock cycle, affecting:
    calls to
      rg_data0.write vs. rg_data0.write
      rg_data1.write vs. rg_data1.write
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "rl_csr_read_start" will appear to fire before "write" when both fire
  in the same clock cycle, affecting:
    calls to rg_start_reg_access.write vs. rg_start_reg_access.write
Warning: "../src_Core/Debug_Module/DM_Abstract_Commands.bsv", line 53, column 8: (G0036)
  Rule "rl_csr_write_finish" will appear to fire before "write" when both fire
  in the same clock cycle, affecting:
    calls to
      rg_abstractcs_busy.write vs. rg_abstractcs_busy.write
      rg_abstractcs_cmderr.write vs. rg_abstractcs_cmderr.write
Verilog file created: Verilog_RTL/mkDM_Abstract_Commands.v
Elaborated module file created: build_dir/mkDM_Abstract_Commands.ba
compiling ../libs/TagController/TagController/MasterSlaveCHERI.bsv
compiling ../libs/TagController/TagController/RoutableCHERI.bsv
compiling ../src_Core/ISA/TV_Info.bsv
compiling ../src_Core/CPU/CPU_Globals.bsv
compiling ../src_Core/BSV_Additional_Libs/ByteLane.bsv
compiling ../libs/BlueStuff/AXI/AXI4_AXI4Lite_Types.bsv
compiling ../libs/BlueStuff/AXI/AXI4_Types.bsv
compiling ../libs/BlueStuff/AXI/AXI4_AW_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4_W_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4_B_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4_AR_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4_R_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4_Utils.bsv
compiling ../libs/BlueStuff/BlueBasics/MasterSlave.bsv
compiling ../libs/TagController/TagController/MemTypesCHERI.bsv
compiling ../libs/TagController/TagController/AXI_Helpers.bsv
compiling ../libs/BlueStuff/BlueBasics/ListExtra.bsv
compiling ../libs/BlueStuff/BlueUtils/SimpleUtils.bsv
compiling ../libs/BlueStuff/BlueUtils/SimUtils.bsv
Foreign import file created: build_dir/sysTime.ba
Foreign import file created: build_dir/printIPC.ba
VPI wrapper files created: Verilog_RTL/vpi_wrapper_sysTime.{c,h}
VPI wrapper files created: Verilog_RTL/vpi_wrapper_printIPC.{c,h}
compiling ../libs/TagController/TagController/CacheCore/Bag.bsv
compiling ../src_SSITH_P2/src_BSV/TagTableStructure.bsv
compiling ../libs/TagController/TagController/Debug.bsv
compiling ../src_Core/RegFiles/GPR_RegFile.bsv
code generation for mkGPR_RegFile starts
Warning: "../src_Core/RegFiles/GPR_RegFile.bsv", line 109, column 8: (G0010)
  Rule "write_rd" was treated as more urgent than "rl_reset_loop". Conflicts:
    "write_rd" cannot fire before "rl_reset_loop":
      calls to regfile.upd vs. regfile.upd
    "rl_reset_loop" cannot fire before "write_rd":
      calls to regfile.upd vs. regfile.upd
Verilog file created: Verilog_RTL/mkGPR_RegFile.v
Elaborated module file created: build_dir/mkGPR_RegFile.ba
compiling ../src_Core/RegFiles/FPR_RegFile.bsv
code generation for mkFPR_RegFile starts
Verilog file created: Verilog_RTL/mkFPR_RegFile.v
Elaborated module file created: build_dir/mkFPR_RegFile.ba
compiling ../src_Core/CPU/CPU_Decode_C.bsv
compiling ../src_Core/CPU/EX_ALU_functions.bsv
compiling ../libs/BlueStuff/OneHotArbiter.bsv
compiling ../libs/BlueStuff/Interconnect.bsv
compiling ../libs/BlueStuff/AXI/AXI4_Interconnect.bsv
compiling ../libs/BlueStuff/AXI/AXI4.bsv
compiling ../src_Core/Core/Fabric_Defs.bsv
compiling ../src_SSITH_P2/src_BSV/SoC_Map.bsv
code generation for mkSoC_Map starts
Verilog file created: Verilog_RTL/mkSoC_Map.v
Elaborated module file created: build_dir/mkSoC_Map.ba
compiling ../src_Core/PLIC/PLIC.bsv
compiling ../src_SSITH_P2/src_BSV/Giraffe_IFC.bsv
compiling ../src_SSITH_P2/src_BSV/JtagTap.bsv
code generation for mkJtagTap starts
Warning: "../src_SSITH_P2/src_BSV/JtagTap.bsv", line 173, column 8: (G0046)
  Reset information for method `jtag_tdi' is lost because the reset is not
  available at the module boundary.
  During elaboration of the interface method `jtag_tdi' at
  "../src_SSITH_P2/src_BSV/JtagTap.bsv", line 173, column 8.
  During elaboration of `mkJtagTap' at "../src_SSITH_P2/src_BSV/JtagTap.bsv",
  line 173, column 8.
Warning: "../src_SSITH_P2/src_BSV/JtagTap.bsv", line 173, column 8: (G0046)
  Reset information for method `jtag_tms' is lost because the reset is not
  available at the module boundary.
  During elaboration of the interface method `jtag_tms' at
  "../src_SSITH_P2/src_BSV/JtagTap.bsv", line 173, column 8.
  During elaboration of `mkJtagTap' at "../src_SSITH_P2/src_BSV/JtagTap.bsv",
  line 173, column 8.
Warning: "../src_SSITH_P2/src_BSV/JtagTap.bsv", line 173, column 8: (G0046)
  Reset information for method `jtag_tdo' is lost because the reset is not
  available at the module boundary.
  During elaboration of the interface method `jtag_tdo' at
  "../src_SSITH_P2/src_BSV/JtagTap.bsv", line 173, column 8.
  During elaboration of `mkJtagTap' at "../src_SSITH_P2/src_BSV/JtagTap.bsv",
  line 173, column 8.
Verilog file created: Verilog_RTL/mkJtagTap.v
Elaborated module file created: build_dir/mkJtagTap.ba
compiling ../src_Core/CPU/CPU_IFC.bsv
compiling ../src_Core/Near_Mem_IO/Near_Mem_IO_AXI4.bsv
code generation for mkNear_Mem_IO_AXI4 starts
Verilog file created: Verilog_RTL/mkNear_Mem_IO_AXI4.v
Elaborated module file created: build_dir/mkNear_Mem_IO_AXI4.ba
compiling ../src_Core/PLIC/PLIC_16_2_7.bsv
code generation for mkPLIC_16_2_7 starts
Verilog file created: Verilog_RTL/mkPLIC_16_2_7.v
Elaborated module file created: build_dir/mkPLIC_16_2_7.ba
compiling ../src_Core/Core/TV_Taps.bsv
code generation for mkDM_Mem_Tap starts
Verilog file created: Verilog_RTL/mkDM_Mem_Tap.v
Elaborated module file created: build_dir/mkDM_Mem_Tap.ba
code generation for mkDM_GPR_Tap starts
Verilog file created: Verilog_RTL/mkDM_GPR_Tap.v
Elaborated module file created: build_dir/mkDM_GPR_Tap.ba
code generation for mkDM_FPR_Tap starts
Verilog file created: Verilog_RTL/mkDM_FPR_Tap.v
Elaborated module file created: build_dir/mkDM_FPR_Tap.ba
code generation for mkDM_CSR_Tap starts
Verilog file created: Verilog_RTL/mkDM_CSR_Tap.v
Elaborated module file created: build_dir/mkDM_CSR_Tap.ba
compiling ../src_Core/Debug_Module/DM_System_Bus.bsv
code generation for mkDM_System_Bus starts
Warning: "../src_Core/Debug_Module/DM_System_Bus.bsv", line 191, column 8: (G0036)
  Rule "reset" will appear to fire before "rl_sb_write_response" when both
  fire in the same clock cycle, affecting:
    calls to rg_sbcs_sberror.write vs. rg_sbcs_sberror.write
Verilog file created: Verilog_RTL/mkDM_System_Bus.v
Elaborated module file created: build_dir/mkDM_System_Bus.ba
compiling ../src_Core/Debug_Module/Debug_Module.bsv
code generation for mkDebug_Module starts
Verilog file created: Verilog_RTL/mkDebug_Module.v
Elaborated module file created: build_dir/mkDebug_Module.ba
compiling ../src_Core/Core/Core_IFC.bsv
compiling ../src_Core/Near_Mem_VM/Near_Mem_IFC.bsv
compiling ../src_Core/CPU/CPU_Fetch_C.bsv
compiling ../src_Core/CPU/CPU_StageD.bsv
Warning: "../src_Core/CPU/CPU_StageD.bsv", line 108, column 41: (T0054)
  Field not defined: `cheri_exc_reg'
Warning: "../src_Core/CPU/CPU_StageD.bsv", line 108, column 41: (T0054)
  Field not defined: `exc_code_cheri'
compiling ../src_Core/RegFiles/CSR_MSTATUS.bsv
compiling ../src_Core/RegFiles/CSR_MIP.bsv
code generation for mkCSR_MIP starts
Warning: "../src_Core/RegFiles/CSR_MIP.bsv", line 71, column 8: (G0036)
  Rule "reset" will appear to fire before "timer_interrupt_req" when both fire
  in the same clock cycle, affecting:
    calls to rg_mtip.write vs. rg_mtip.write
Warning: "../src_Core/RegFiles/CSR_MIP.bsv", line 71, column 8: (G0036)
  Rule "reset" will appear to fire before "software_interrupt_req" when both
  fire in the same clock cycle, affecting:
    calls to rg_msip.write vs. rg_msip.write
Warning: "../src_Core/RegFiles/CSR_MIP.bsv", line 71, column 8: (G0036)
  Rule "reset" will appear to fire before "s_external_interrupt_req" when both
  fire in the same clock cycle, affecting:
    calls to rg_seip.write vs. rg_seip.write
Warning: "../src_Core/RegFiles/CSR_MIP.bsv", line 71, column 8: (G0036)
  Rule "fav_write" will appear to fire before "s_external_interrupt_req" when
  both fire in the same clock cycle, affecting:
    calls to rg_seip.write vs. rg_seip.write
Warning: "../src_Core/RegFiles/CSR_MIP.bsv", line 71, column 8: (G0036)
  Rule "reset" will appear to fire before "m_external_interrupt_req" when both
  fire in the same clock cycle, affecting:
    calls to rg_meip.write vs. rg_meip.write
Verilog file created: Verilog_RTL/mkCSR_MIP.v
Elaborated module file created: build_dir/mkCSR_MIP.ba
compiling ../src_Core/RegFiles/CSR_MIE.bsv
code generation for mkCSR_MIE starts
Warning: "../src_Core/RegFiles/CSR_MIE.bsv", line 58, column 8: (G0036)
  Rule "reset" will appear to fire before "fav_write" when both fire in the
  same clock cycle, affecting:
    calls to rg_mie.write vs. rg_mie.write
Verilog file created: Verilog_RTL/mkCSR_MIE.v
Elaborated module file created: build_dir/mkCSR_MIE.ba
compiling ../src_Core/RegFiles/CSR_RegFile_MSU.bsv
code generation for mkCSR_RegFile starts
Warning: "../src_Core/RegFiles/CSR_RegFile_MSU.bsv", line 320, column 8: (G0010)
  Rule "mav_csr_write" was treated as more urgent than
  "rl_reset_start". Conflicts:
    "mav_csr_write" cannot fire before "rl_reset_start":
      calls to
	csr_mie.fav_write vs. csr_mie.reset
	rw_minstret.wset vs. rw_minstret.wset
    "rl_reset_start" cannot fire before "mav_csr_write":
      calls to
	rg_stcc.write vs. rg_stcc.read
	rg_sepcc.write vs. rg_sepcc.read
	csr_mie.reset vs. csr_mie.fav_sie_write
	csr_mip.reset vs. csr_mip.fav_sip_write
	csr_mip.reset vs. csr_mip.fav_write
	rg_mtcc.write vs. rg_mtcc.read
	rg_mepcc.write vs. rg_mepcc.read
	rw_minstret.wset vs. rw_minstret.wset
	rg_dcsr.write vs. rg_dcsr.read
	rg_dpcc.write vs. rg_dpcc.read
	csr_mstatus_rg_mstatus.write vs. csr_mstatus_rg_mstatus.read
Warning: "../src_Core/RegFiles/CSR_RegFile_MSU.bsv", line 320, column 8: (G0036)
  Rule "write_dpcc" will appear to fire before "rl_reset_start" when both fire
  in the same clock cycle, affecting:
    calls to rg_dpcc.write vs. rg_dpcc.write
Warning: "../src_Core/RegFiles/CSR_RegFile_MSU.bsv", line 320, column 8: (G0036)
  Rule "mav_scr_write" will appear to fire before "rl_reset_start" when both
  fire in the same clock cycle, affecting:
    calls to
      rg_stcc.write vs. rg_stcc.write
      rg_sepcc.write vs. rg_sepcc.write
      rg_mtcc.write vs. rg_mtcc.write
      rg_mepcc.write vs. rg_mepcc.write
Warning: "../src_Core/RegFiles/CSR_RegFile_MSU.bsv", line 320, column 8: (G0036)
  Rule "nmi_req" will appear to fire before "rl_reset_start" when both fire in
  the same clock cycle, affecting:
    calls to rg_nmi.write vs. rg_nmi.write
Verilog file created: Verilog_RTL/mkCSR_RegFile.v
Elaborated module file created: build_dir/mkCSR_RegFile.ba
compiling ../src_Core/RegFiles/CSR_RegFile.bsv
compiling ../src_Core/CPU/CPU_Stage1.bsv
Warning: "../src_Core/CPU/CPU_Stage1.bsv", line 324, column 31: (T0054)
  Field not defined: `val2_flt_not_int'
Warning: "../src_Core/CPU/CPU_Stage1.bsv", line 324, column 31: (T0054)
  Field not defined: `val1_flt_not_int'
compiling ../src_Core/CPU/CPU_Stage3.bsv
compiling ../src_Core/CPU/Branch_Predictor.bsv
code generation for mkBranch_Predictor starts
Verilog file created: Verilog_RTL/mkBranch_Predictor.v
Elaborated module file created: build_dir/mkBranch_Predictor.ba
compiling ../src_Core/CPU/CPU_StageF.bsv
Warning: "../src_Core/CPU/CPU_StageF.bsv", line 121, column 15: (T0054)
  Field not defined: `cheri_exc_reg'
Warning: "../src_Core/CPU/CPU_StageF.bsv", line 121, column 15: (T0054)
  Field not defined: `exc_code_cheri'
compiling ../src_Core/CPU/IntMulDiv.bsv
code generation for mkIntMul_64 starts
Verilog file created: Verilog_RTL/mkIntMul_64.v
Elaborated module file created: build_dir/mkIntMul_64.ba
code generation for mkIntMul_32 starts
Verilog file created: Verilog_RTL/mkIntMul_32.v
Elaborated module file created: build_dir/mkIntMul_32.ba
compiling ../src_Core/CPU/RISCV_MBox.bsv
code generation for mkRISCV_MBox starts
Verilog file created: Verilog_RTL/mkRISCV_MBox.v
Elaborated module file created: build_dir/mkRISCV_MBox.ba
compiling ../src_Core/BSV_Additional_Libs/CreditCounter.bsv
compiling ../src_Core/Near_Mem_VM/TLB.bsv
code generation for mkTLB starts
Verilog file created: Verilog_RTL/mkTLB.v
Elaborated module file created: build_dir/mkTLB.ba
compiling ../src_Core/Near_Mem_VM/Cache_Decls_RV64.bsv
compiling ../src_Core/Near_Mem_VM/MMU_Cache.bsv
code generation for mkMMU_ICache starts
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 459, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_rl_start_tlb_refill". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_rl_start_tlb_refill":
      calls to cache_rg_state.write vs. cache_rg_state.read
    "cache_rl_start_tlb_refill" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 459, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_rl_ptw_level_2". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_rl_ptw_level_2":
      calls to
	cache_rg_state.write vs. cache_rg_state.read
	cache_tlb.flush vs. cache_tlb.insert
    "cache_rl_ptw_level_2" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 459, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_rl_ptw_level_1". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_rl_ptw_level_1":
      calls to
	cache_rg_state.write vs. cache_rg_state.read
	cache_tlb.flush vs. cache_tlb.insert
    "cache_rl_ptw_level_1" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 459, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_rl_ptw_level_0". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_rl_ptw_level_0":
      calls to
	cache_rg_state.write vs. cache_rg_state.read
	cache_tlb.flush vs. cache_tlb.insert
    "cache_rl_ptw_level_0" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 459, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_do_req". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_do_req":
      calls to cache_rg_state.write vs. cache_rg_state.read
    "cache_do_req" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 459, column 8: (G0036)
  Rule "cache_rl_reset" will appear to fire before
  "cache_master_xactor_do_clear" when both fire in the same clock
  cycle, affecting:
    calls to
      cache_master_xactor_clearing.write vs. cache_master_xactor_clearing.write
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 459, column 8: (G0036)
  Rule "cache_rl_start_reset" will appear to fire before
  "cache_rl_discard_write_rsp" when both fire in the same clock
  cycle, affecting:
    calls to
      cache_ctr_wr_rsps_pending_outrg.write vs. cache_ctr_wr_rsps_pending_outrg.write
Verilog file created: Verilog_RTL/mkMMU_ICache.v
Elaborated module file created: build_dir/mkMMU_ICache.ba
code generation for mkMMU_DCache starts
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 464, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_rl_start_tlb_refill". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_rl_start_tlb_refill":
      calls to cache_rg_state.write vs. cache_rg_state.read
    "cache_rl_start_tlb_refill" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 464, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_rl_ptw_level_2". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_rl_ptw_level_2":
      calls to
	cache_rg_state.write vs. cache_rg_state.read
	cache_tlb.flush vs. cache_tlb.insert
    "cache_rl_ptw_level_2" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 464, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_rl_ptw_level_1". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_rl_ptw_level_1":
      calls to
	cache_rg_state.write vs. cache_rg_state.read
	cache_tlb.flush vs. cache_tlb.insert
    "cache_rl_ptw_level_1" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 464, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_rl_ptw_level_0". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_rl_ptw_level_0":
      calls to
	cache_rg_state.write vs. cache_rg_state.read
	cache_tlb.flush vs. cache_tlb.insert
    "cache_rl_ptw_level_0" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 464, column 8: (G0010)
  Rule "cache_rl_start_reset" was treated as more urgent than
  "cache_do_req". Conflicts:
    "cache_rl_start_reset" cannot fire before "cache_do_req":
      calls to cache_rg_state.write vs. cache_rg_state.read
    "cache_do_req" cannot fire before "cache_rl_start_reset":
      calls to cache_rg_state.write vs. cache_rg_state.read
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 464, column 8: (G0036)
  Rule "cache_rl_reset" will appear to fire before
  "cache_master_xactor_do_clear" when both fire in the same clock
  cycle, affecting:
    calls to
      cache_master_xactor_clearing.write vs. cache_master_xactor_clearing.write
Warning: "../src_Core/Near_Mem_VM/MMU_Cache.bsv", line 464, column 8: (G0036)
  Rule "cache_rl_start_reset" will appear to fire before
  "cache_rl_discard_write_rsp" when both fire in the same clock
  cycle, affecting:
    calls to
      cache_ctr_wr_rsps_pending_outrg.write vs. cache_ctr_wr_rsps_pending_outrg.write
Verilog file created: Verilog_RTL/mkMMU_DCache.v
Elaborated module file created: build_dir/mkMMU_DCache.ba
compiling ../src_Core/Near_Mem_VM/Near_Mem_Caches.bsv
code generation for mkNear_Mem starts
Warning: "../src_Core/Near_Mem_VM/Near_Mem_Caches.bsv", line 74, column 8: (G0010)
  Rule "server_fence_request_put" was treated as more urgent than
  "rl_reset". Conflicts:
    "server_fence_request_put" cannot fire before "rl_reset":
      calls to
	dcache.server_flush_request_put vs. dcache.server_reset_request_put
    "rl_reset" cannot fire before "server_fence_request_put":
      calls to
	dcache.server_reset_request_put vs. dcache.server_flush_request_put
Verilog file created: Verilog_RTL/mkNear_Mem.v
Elaborated module file created: build_dir/mkNear_Mem.ba
compiling ../libs/BlueStuff/BlueBasics/Virtualizable.bsv
compiling ../libs/TagController/TagController/CacheCore/MEM.bsv
compiling ../src_Core/CPU/FPU.bsv
code generation for mkFPU starts
Warning: "../src_Core/CPU/FPU.bsv", line 37, column 8: (G0010)
  Rule "work" was treated as more urgent than "fpu_div64_s2_stage". Conflicts:
    "work" cannot fire before "fpu_div64_s2_stage":
      calls to rg_busy.write vs. rg_busy.read
    "fpu_div64_s2_stage" cannot fire before "work":
      calls to
	rg_index.write vs. rg_index.read
	rg_d.write vs. rg_d.read
	rg_q.write vs. rg_q.read
	rg_r.write vs. rg_r.read
	rg_busy.write vs. rg_busy.read
Warning: "../src_Core/CPU/FPU.bsv", line 37, column 8: (G0010)
  Rule "work_1" was treated as more urgent than
  "fpu_sqr64_s2_stage". Conflicts:
    "work_1" cannot fire before "fpu_sqr64_s2_stage":
      calls to rg_busy_1.write vs. rg_busy_1.read
    "fpu_sqr64_s2_stage" cannot fire before "work_1":
      calls to
	rg_res.write vs. rg_res.read
	rg_s.write vs. rg_s.read
	rg_b.write vs. rg_b.read
	rg_r_1.write vs. rg_r_1.read
	rg_busy_1.write vs. rg_busy_1.read
	rg_index_1.write vs. rg_index_1.read
Verilog file created: Verilog_RTL/mkFPU.v
Elaborated module file created: build_dir/mkFPU.ba
compiling ../src_Core/CPU/FBox_Core.bsv
code generation for mkFBox_Core starts
Warning: "../src_Core/CPU/FBox_Core.bsv", line 134, column 8: (G0036)
  Rule "req" will appear to fire before "rl_reset_begin" when both fire in the
  same clock cycle, affecting:
    calls to
      stateR.write vs. stateR.write
      requestR.write vs. requestR.write
      resultR.write vs. resultR.write
Verilog file created: Verilog_RTL/mkFBox_Core.v
Elaborated module file created: build_dir/mkFBox_Core.ba
compiling ../src_Core/CPU/FBox_Top.bsv
code generation for mkFBox_Top starts
Verilog file created: Verilog_RTL/mkFBox_Top.v
Elaborated module file created: build_dir/mkFBox_Top.ba
compiling ../src_Core/CPU/CPU_Stage2.bsv
Warning: "../src_Core/CPU/CPU_Stage2.bsv", line 263, column 26: (T0054)
  Field not defined: `check_success'
Warning: "../src_Core/CPU/CPU_Stage2.bsv", line 287, column 26: (T0054)
  Field not defined: `check_success'
Warning: "../src_Core/CPU/CPU_Stage2.bsv", line 450, column 29: (T0054)
  Field not defined: `check_success'
Warning: "../src_Core/CPU/CPU_Stage2.bsv", line 489, column 26: (T0054)
  Field not defined: `check_success'
Warning: "../src_Core/CPU/CPU_Stage2.bsv", line 568, column 26: (T0054)
  Field not defined: `check_success'
Warning: "../src_Core/CPU/CPU_Stage2.bsv", line 632, column 26: (T0054)
  Field not defined: `check_success'
compiling ../src_Core/CPU/CPU.bsv
code generation for mkCPU starts
Warning: "../src_Core/CPU/CPU_Fetch_C.bsv", line 118, column 9: (G0023)
  The condition for rule `imem_rl_debug_conds' is always false. Removing...
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage2_nonpipe" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_stage2_nonpipe" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage2_nonpipe":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_SCR_W" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_stage1_SCR_W" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_SCR_W":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_SCR_W_2" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_stage1_SCR_W_2" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_SCR_W_2":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_CSRR_S_or_C_2" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_stage1_CSRR_S_or_C_2" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_CSRR_S_or_C_2":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_CSRR_W" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_stage1_CSRR_W" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_CSRR_W":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_CSRR_W_2" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_stage1_CSRR_W_2" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_CSRR_W_2":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_CSRR_S_or_C" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_stage1_CSRR_S_or_C" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_CSRR_S_or_C":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_WFI" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_reset_from_WFI" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_reset_from_WFI":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_BREAK_cache_flush_finish" was treated as more urgent than
  "rl_reset_from_Debug_Module". Conflicts:
    "rl_BREAK_cache_flush_finish" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_from_Debug_Module" cannot fire before "rl_BREAK_cache_flush_finish":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_SCR_W" was treated as more urgent than
  "rl_debug_halt". Conflicts:
    "rl_stage1_SCR_W" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
    "rl_debug_halt" cannot fire before "rl_stage1_SCR_W":
      calls to rg_stop_req.write vs. rg_stop_req.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_CSRR_W" was treated as more urgent than
  "rl_debug_halt". Conflicts:
    "rl_stage1_CSRR_W" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
    "rl_debug_halt" cannot fire before "rl_stage1_CSRR_W":
      calls to rg_stop_req.write vs. rg_stop_req.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_CSRR_S_or_C" was treated as more urgent than
  "rl_debug_halt". Conflicts:
    "rl_stage1_CSRR_S_or_C" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
    "rl_debug_halt" cannot fire before "rl_stage1_CSRR_S_or_C":
      calls to rg_stop_req.write vs. rg_stop_req.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_stage1_trap". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_trap":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_trap" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_halt" was treated as more urgent than
  "rl_stage1_trap". Conflicts:
    "rl_debug_halt" cannot fire before "rl_stage1_trap":
      calls to rg_stop_req.write vs. rg_stop_req.read
    "rl_stage1_trap" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_trap". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_trap":
      calls to rg_state.write vs. rg_state.read
    "rl_trap" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_stage1_restart_after_csrrx". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_restart_after_csrrx":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_restart_after_csrrx" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_stage1_xRET". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_xRET":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_xRET" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_halt" was treated as more urgent than
  "rl_stage1_xRET". Conflicts:
    "rl_debug_halt" cannot fire before "rl_stage1_xRET":
      calls to rg_stop_req.write vs. rg_stop_req.read
    "rl_stage1_xRET" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_finish_FENCE_I". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_finish_FENCE_I":
      calls to rg_state.write vs. rg_state.read
    "rl_finish_FENCE_I" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_stage1_FENCE_I". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_FENCE_I":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_FENCE_I" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_halt" was treated as more urgent than
  "rl_stage1_FENCE_I". Conflicts:
    "rl_debug_halt" cannot fire before "rl_stage1_FENCE_I":
      calls to rg_stop_req.write vs. rg_stop_req.read
    "rl_stage1_FENCE_I" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_stage1_FENCE". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_FENCE":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_FENCE" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_halt" was treated as more urgent than
  "rl_stage1_FENCE". Conflicts:
    "rl_debug_halt" cannot fire before "rl_stage1_FENCE":
      calls to rg_stop_req.write vs. rg_stop_req.read
    "rl_stage1_FENCE" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_finish_FENCE". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_finish_FENCE":
      calls to rg_state.write vs. rg_state.read
    "rl_finish_FENCE" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_stage1_SFENCE_VMA". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_SFENCE_VMA":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_SFENCE_VMA" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_halt" was treated as more urgent than
  "rl_stage1_SFENCE_VMA". Conflicts:
    "rl_debug_halt" cannot fire before "rl_stage1_SFENCE_VMA":
      calls to rg_stop_req.write vs. rg_stop_req.read
    "rl_stage1_SFENCE_VMA" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_finish_SFENCE_VMA". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_finish_SFENCE_VMA":
      calls to rg_state.write vs. rg_state.read
    "rl_finish_SFENCE_VMA" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_stage1_WFI". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_stage1_WFI":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_WFI" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_halt" was treated as more urgent than
  "rl_stage1_WFI". Conflicts:
    "rl_debug_halt" cannot fire before "rl_stage1_WFI":
      calls to rg_stop_req.write vs. rg_stop_req.read
    "rl_stage1_WFI" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_WFI_resume". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_WFI_resume":
      calls to rg_state.write vs. rg_state.read
    "rl_WFI_resume" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_trap_fetch". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_trap_fetch":
      calls to rg_state.write vs. rg_state.read
    "rl_trap_fetch" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_trap_BREAK_to_Debug_Mode". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_trap_BREAK_to_Debug_Mode":
      calls to rg_state.write vs. rg_state.read
    "rl_trap_BREAK_to_Debug_Mode" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_run_redundant" was treated as more urgent than
  "rl_trap_BREAK_to_Debug_Mode". Conflicts:
    "rl_debug_run_redundant" cannot fire before "rl_trap_BREAK_to_Debug_Mode":
      calls to f_run_halt_rsps.enq vs. f_run_halt_rsps.enq
    "rl_trap_BREAK_to_Debug_Mode" cannot fire before "rl_debug_run_redundant":
      calls to
	rg_state.write vs. rg_state.read
	f_run_halt_rsps.enq vs. f_run_halt_rsps.enq
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_halt" was treated as more urgent than
  "rl_trap_BREAK_to_Debug_Mode". Conflicts:
    "rl_debug_halt" cannot fire before "rl_trap_BREAK_to_Debug_Mode":
      calls to rg_stop_req.write vs. rg_stop_req.read
    "rl_trap_BREAK_to_Debug_Mode" cannot fire before "rl_debug_halt":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_trap" was treated as more urgent than
  "rl_stage1_interrupt". Conflicts:
    "rl_stage1_trap" cannot fire before "rl_stage1_interrupt":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_interrupt" cannot fire before "rl_stage1_trap":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_interrupt" was treated as more urgent than
  "rl_stage1_stop". Conflicts:
    "rl_stage1_interrupt" cannot fire before "rl_stage1_stop":
      calls to rg_state.write vs. rg_state.read
    "rl_stage1_stop" cannot fire before "rl_stage1_interrupt":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_debug_run". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_debug_run":
      calls to rg_state.write vs. rg_state.read
    "rl_debug_run" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_debug_write_csr" was treated as more urgent than
  "rl_debug_run". Conflicts:
    "rl_debug_write_csr" cannot fire before "rl_debug_run":
      calls to
	csr_regfile.mav_csr_write vs. csr_regfile.read_mstatus
	csr_regfile.mav_csr_write vs. csr_regfile.read_satp
	csr_regfile.mav_csr_write vs. csr_regfile.read_sstatus
	csr_regfile.mav_csr_write vs. csr_regfile.read_dpcc
    "rl_debug_run" cannot fire before "rl_debug_write_csr":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_reset_from_Debug_Module" was treated as more urgent than
  "rl_reset_complete". Conflicts:
    "rl_reset_from_Debug_Module" cannot fire before "rl_reset_complete":
      calls to rg_state.write vs. rg_state.read
    "rl_reset_complete" cannot fire before "rl_reset_from_Debug_Module":
      calls to rg_state.write vs. rg_state.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0010)
  Rule "rl_stage1_stop" was treated as more urgent than "rl_pipe". Conflicts:
    "rl_stage1_stop" cannot fire before "rl_pipe":
      calls to
	csr_regfile.write_dcsr_cause_priv vs. csr_regfile.read_dcsr_step
	rg_state.write vs. rg_state.read
	rg_next_pcc.write vs. rg_next_pcc.read
	rg_stop_req.write vs. rg_stop_req.read
	rg_step_count.write vs. rg_step_count.read
    "rl_pipe" cannot fire before "rl_stage1_stop":
      calls to
	gpr_regfile.write_rd vs. gpr_regfile.read_rs1
	gpr_regfile.write_rd vs. gpr_regfile.read_rs2
	csr_regfile.ma_update_mstatus_fs vs. csr_regfile.read_mstatus
	csr_regfile.ma_update_mstatus_fs vs. csr_regfile.interrupt_pending
	rg_epoch.write vs. rg_epoch.read
	rg_step_count.write vs. rg_step_count.read
	imem_rg_pc.write vs. imem_rg_pc.read
	stage3_rg_full.write vs. stage3_rg_full.read
	stage3_rg_stage3.write vs. stage3_rg_stage3.read
	stage2_rg_full.write vs. stage2_rg_full.read
	stage2_rg_stage2.write vs. stage2_rg_stage2.read
	stage1_rg_full.write vs. stage1_rg_full.read
	stage1_rg_stage_input.write vs. stage1_rg_stage_input.read
	stageF_rg_full.write vs. stageF_rg_full.read
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0036)
  Rule "rl_trap_fetch" will appear to fire before "stageF_rl_reset" when both
  fire in the same clock cycle, affecting:
    calls to
      stageF_rg_full.write vs. stageF_rg_full.write
      stageF_rg_epoch.write vs. stageF_rg_epoch.write
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0036)
  Rule "rl_finish_SFENCE_VMA" will appear to fire before "stageF_rl_reset"
  when both fire in the same clock cycle, affecting:
    calls to
      stageF_rg_full.write vs. stageF_rg_full.write
      stageF_rg_epoch.write vs. stageF_rg_epoch.write
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0036)
  Rule "rl_finish_FENCE" will appear to fire before "stageF_rl_reset" when
  both fire in the same clock cycle, affecting:
    calls to
      stageF_rg_full.write vs. stageF_rg_full.write
      stageF_rg_epoch.write vs. stageF_rg_epoch.write
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0036)
  Rule "rl_finish_FENCE_I" will appear to fire before "stageF_rl_reset" when
  both fire in the same clock cycle, affecting:
    calls to
      stageF_rg_full.write vs. stageF_rg_full.write
      stageF_rg_epoch.write vs. stageF_rg_epoch.write
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0036)
  Rule "rl_reset_complete" will appear to fire before "stageF_rl_reset" when
  both fire in the same clock cycle, affecting:
    calls to
      stageF_rg_full.write vs. stageF_rg_full.write
      stageF_rg_epoch.write vs. stageF_rg_epoch.write
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0036)
  Rule "rl_debug_run" will appear to fire before "stageF_rl_reset" when both
  fire in the same clock cycle, affecting:
    calls to
      stageF_rg_full.write vs. stageF_rg_full.write
      stageF_rg_epoch.write vs. stageF_rg_epoch.write
Warning: "../src_Core/CPU/CPU.bsv", line 150, column 8: (G0036)
  Rule "set_verbosity" will appear to fire before "hart0_put_other_req_put"
  when both fire in the same clock cycle, affecting:
    calls to cfg_verbosity.write vs. cfg_verbosity.write
Verilog file created: Verilog_RTL/mkCPU.v
Elaborated module file created: build_dir/mkCPU.ba
compiling ../libs/BlueStuff/AXI/AXI4Lite_Types.bsv
compiling ../libs/BlueStuff/AXI/AXI4Lite_AW_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4Lite_W_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4Lite_B_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4Lite_AR_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4Lite_R_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4Lite_Utils.bsv
compiling ../libs/BlueStuff/AXI/AXI4Lite_Interconnect.bsv
compiling ../libs/BlueStuff/AXI/AXI4_AXI4Lite_Bridges.bsv
compiling ../libs/BlueStuff/AXI/AXI.bsv
compiling ../libs/BlueStuff/BlueUtils/MemTypes.bsv
compiling ../libs/BlueStuff/BlueUtils/MemBRAM.bsv
compiling ../libs/BlueStuff/BlueUtils/MemSim.bsv
Foreign import file created: build_dir/mem_create.ba
Foreign import file created: build_dir/mem_init.ba
Foreign import file created: build_dir/mem_zero.ba
Foreign import file created: build_dir/mem_read.ba
Foreign import file created: build_dir/mem_write.ba
VPI wrapper files created: Verilog_RTL/vpi_wrapper_mem_create.{c,h}
VPI wrapper files created: Verilog_RTL/vpi_wrapper_mem_init.{c,h}
VPI wrapper files created: Verilog_RTL/vpi_wrapper_mem_zero.{c,h}
VPI wrapper files created: Verilog_RTL/vpi_wrapper_mem_read.{c,h}
VPI wrapper files created: Verilog_RTL/vpi_wrapper_mem_write.{c,h}
compiling ../libs/BlueStuff/BlueUtils/MemUtils.bsv
compiling ../libs/BlueStuff/BlueUtils/Mem.bsv
compiling ../libs/BlueStuff/BlueUtils/FF.bsv
compiling ../libs/BlueStuff/BlueUtils/BlueUtils.bsv
compiling ../libs/TagController/TagController/CacheCore/UGFFFullOfUniqueInts.bsv
compiling ../libs/TagController/TagController/CacheCore/CacheCorderer.bsv
compiling ../libs/TagController/TagController/CacheCore/CacheCore.bsv
compiling ../libs/TagController/TagController/MultiLevelTagLookup.bsv
Warning: "../libs/TagController/TagController/MultiLevelTagLookup.bsv", line 401, column 39: (T0054)
  Field not defined: `length'
Warning: "../libs/TagController/TagController/MultiLevelTagLookup.bsv", line 84, column 10: (T0127)
  Exporting orphan typeclass instance FShow#(Integer). The instance's
  typeclass as well as all of the instance's source type parameters are
  defined in other packages. This can lead to confusing and inconsistent
  instance resolution if the orphan instance is not imported everywhere it
  could be used.
compiling ../libs/TagController/TagController/TagController.bsv
code generation for mkTagController starts
Verilog file created: Verilog_RTL/mkTagController.v
Elaborated module file created: build_dir/mkTagController.ba
compiling ../libs/TagController/TagController/TagControllerAXI.bsv
compiling ../src_Core/Core/Core.bsv
code generation for mkCore starts
Warning: "../libs/TagController/TagController/TagControllerAXI.bsv", line 88, column 8: (G0043)
  Multiple reset signals influence rule `tagController_tmp_passCacheWrite'.
  This can lead to inconsistent, non-atomic results when not all of these
  signals are asserted.
  Method calls by reset:
    Reset 1 (default_reset):
      tagController_tmp_addrOffset.read
      tagController_tmp_addrOffset.write
      tagController_tmp_awreqff.deq
      tagController_tmp_awreqff.first
      tagController_tmp_awreqff.i_notEmpty
      tagController_tmp_shimSlave_wff_rv.port1__read
      tagController_tmp_shimSlave_wff_rv.port1__write
    Reset 2 (tagController_tmp_newRst.new_rst):
      tagController_tmp_tagCon.RDY_cache_request_put at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 48, column 18,
      tagController_tmp_tagCon.cache_request_put at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 48, column 18,
  During elaboration of rule `passCacheWrite' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 88, column
  8.
  During elaboration of `tmp' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 66, column
  7.
  During elaboration of `tagController' at "../src_Core/Core/Core.bsv", line
  100, column 8.
  During elaboration of `mkCore' at "../src_Core/Core/Core.bsv", line 83,
  column 8.
Warning: "../libs/TagController/TagController/TagControllerAXI.bsv", line 103, column 8: (G0043)
  Multiple reset signals influence rule `tagController_tmp_passCacheRead'.
  This can lead to inconsistent, non-atomic results when not all of these
  signals are asserted.
  Method calls by reset:
    Reset 1 (default_reset):
      tagController_tmp_shimSlave_arff_rv.port1__read
      tagController_tmp_shimSlave_arff_rv.port1__write
    Reset 2 (tagController_tmp_newRst.new_rst):
      tagController_tmp_tagCon.RDY_cache_request_put at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 48, column 18,
      tagController_tmp_tagCon.cache_request_put at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 48, column 18,
  During elaboration of rule `passCacheRead' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 103, column
  8.
  During elaboration of `tmp' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 66, column
  7.
  During elaboration of `tagController' at "../src_Core/Core/Core.bsv", line
  100, column 8.
  During elaboration of `mkCore' at "../src_Core/Core/Core.bsv", line 83,
  column 8.
Warning: "../libs/TagController/TagController/TagControllerAXI.bsv", line 108, column 8: (G0043)
  Multiple reset signals influence rule `tagController_tmp_passCacheResponse'.
  This can lead to inconsistent, non-atomic results when not all of these
  signals are asserted.
  Method calls by reset:
    Reset 1 (default_reset):
      tagController_tmp_shimSlave_bff_rv.port0__read
      tagController_tmp_shimSlave_bff_rv.port0__write
      tagController_tmp_shimSlave_rff_rv.port0__read
      tagController_tmp_shimSlave_rff_rv.port0__write
    Reset 2 (tagController_tmp_newRst.new_rst):
      tagController_tmp_tagCon.RDY_cache_response_get at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 111, column 27,
      tagController_tmp_tagCon.cache_response_get at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 111, column 27,
  During elaboration of rule `passCacheResponse' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 108, column
  8.
  During elaboration of `tmp' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 66, column
  7.
  During elaboration of `tagController' at "../src_Core/Core/Core.bsv", line
  100, column 8.
  During elaboration of `mkCore' at "../src_Core/Core/Core.bsv", line 83,
  column 8.
Warning: "../libs/TagController/TagController/TagControllerAXI.bsv", line 120, column 8: (G0043)
  Multiple reset signals influence rule `tagController_tmp_passMemoryRequest'.
  This can lead to inconsistent, non-atomic results when not all of these
  signals are asserted.
  Method calls by reset:
    Reset 1 (default_reset):
      tagController_tmp_doneSendingAW.read
      tagController_tmp_doneSendingAW.write
      tagController_tmp_shimMaster_arff_rv.port0__read
      tagController_tmp_shimMaster_arff_rv.port0__write
      tagController_tmp_shimMaster_awff_rv.port0__read
      tagController_tmp_shimMaster_awff_rv.port0__write
      tagController_tmp_shimMaster_wff_rv.port0__read
      tagController_tmp_shimMaster_wff_rv.port0__write
    Reset 2 (tagController_tmp_newRst.new_rst):
      tagController_tmp_tagCon.RDY_memory_request_get at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 111, column 27,
      tagController_tmp_tagCon.memory_request_get at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 111, column 27,
  During elaboration of rule `passMemoryRequest' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 120, column
  8.
  During elaboration of `tmp' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 66, column
  7.
  During elaboration of `tagController' at "../src_Core/Core/Core.bsv", line
  100, column 8.
  During elaboration of `mkCore' at "../src_Core/Core/Core.bsv", line 83,
  column 8.
Warning: "../libs/TagController/TagController/TagControllerAXI.bsv", line 139, column 8: (G0043)
  Multiple reset signals influence rule
  `tagController_tmp_passMemoryResponseWrite'.
  This can lead to inconsistent, non-atomic results when not all of these
  signals are asserted.
  Method calls by reset:
    Reset 1 (default_reset):
      tagController_tmp_shimMaster_bff_rv.port1__read
      tagController_tmp_shimMaster_bff_rv.port1__write
    Reset 2 (tagController_tmp_newRst.new_rst):
      tagController_tmp_tagCon.RDY_memory_response_put at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 48, column 18,
      tagController_tmp_tagCon.memory_response_put at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 48, column 18,
  During elaboration of rule `passMemoryResponseWrite' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 139, column
  8.
  During elaboration of `tmp' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 66, column
  7.
  During elaboration of `tagController' at "../src_Core/Core/Core.bsv", line
  100, column 8.
  During elaboration of `mkCore' at "../src_Core/Core/Core.bsv", line 83,
  column 8.
Warning: "../libs/TagController/TagController/TagControllerAXI.bsv", line 145, column 8: (G0043)
  Multiple reset signals influence rule
  `tagController_tmp_passMemoryResponseRead'.
  This can lead to inconsistent, non-atomic results when not all of these
  signals are asserted.
  Method calls by reset:
    Reset 1 (default_reset):
      tagController_tmp_shimMaster_rff_rv.port1__read
      tagController_tmp_shimMaster_rff_rv.port1__write
    Reset 2 (tagController_tmp_newRst.new_rst):
      tagController_tmp_tagCon.RDY_memory_response_put at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 48, column 18,
      tagController_tmp_tagCon.memory_response_put at "../libs/TagController/TagController/MasterSlaveCHERI.bsv", line 48, column 18,
  During elaboration of rule `passMemoryResponseRead' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 145, column
  8.
  During elaboration of `tmp' at
  "../libs/TagController/TagController/TagControllerAXI.bsv", line 66, column
  7.
  During elaboration of `tagController' at "../src_Core/Core/Core.bsv", line
  100, column 8.
  During elaboration of `mkCore' at "../src_Core/Core/Core.bsv", line 83,
  column 8.
Warning: "../src_Core/Core/Core.bsv", line 83, column 8: (G0010)
  Rule "mkConnectionGetPut" was treated as more urgent than
  "cpu_imem_ug_u_aw_doDrop". Conflicts:
    "mkConnectionGetPut" cannot fire before "cpu_imem_ug_u_aw_doDrop":
      calls to delay_shim_awff.enq vs. delay_shim_awff.notEmpty
    "cpu_imem_ug_u_aw_doDrop" cannot fire before "mkConnectionGetPut":
      calls to delay_shim_awff.deq vs. delay_shim_awff.notFull
Warning: "../src_Core/Core/Core.bsv", line 83, column 8: (G0010)
  Rule "mkConnectionGetPut_1" was treated as more urgent than
  "cpu_imem_ug_u_w_doDrop". Conflicts:
    "mkConnectionGetPut_1" cannot fire before "cpu_imem_ug_u_w_doDrop":
      calls to delay_shim_wff.enq vs. delay_shim_wff.notEmpty
    "cpu_imem_ug_u_w_doDrop" cannot fire before "mkConnectionGetPut_1":
      calls to delay_shim_wff.deq vs. delay_shim_wff.notFull
Warning: "../src_Core/Core/Core.bsv", line 83, column 8: (G0010)
  Rule "cpu_imem_ug_u_ar_doDrop" was treated as more urgent than
  "mkConnectionGetPut_3". Conflicts:
    "cpu_imem_ug_u_ar_doDrop" cannot fire before "mkConnectionGetPut_3":
      calls to delay_shim_arff.deq vs. delay_shim_arff.notFull
    "mkConnectionGetPut_3" cannot fire before "cpu_imem_ug_u_ar_doDrop":
      calls to delay_shim_arff.enq vs. delay_shim_arff.notEmpty
Warning: "../src_Core/Core/Core.bsv", line 92, column 13: (G0015)
  Instance `cpu' requires the following methods to be always enabled, but the
  conditions for executing the methods could not be proven to be always True:
    software_interrupt_req, timer_interrupt_req
  The behavior of the design will likely be incorrect if the methods are not
  enabled on every clock cycle.
Verilog file created: Verilog_RTL/mkCore.v
Elaborated module file created: build_dir/mkCore.ba
compiling src_BSV/P2_Core.bsv
code generation for mkP2_Core starts
Warning: "src_BSV/P2_Core.bsv", line 125, column 9: (G0023)
  The condition for rule `rl_never' is always false. Removing...
Warning: "src_BSV/P2_Core.bsv", line 216, column 9: (G0100)
  The rules `RL_rl_dmi_req_cpu' and `RL_rl_dmi_rsp_cpu' require dynamic
  scheduling, which is not supported by Bluesim. This is because the rules use
  methods which have a rule that executes between them in the static execution
  order of the separately synthesized submodule, but the rules must execute in
  the opposite order according to the current module's schedule. See entry #30
  in the KPNS document for more information and possible solutions.
  The methods and the rules between them are as follows:
    (core.dm_dmi_write, core.dm_dmi_read_data)
      debug_module.dm_abstract_commands.RL_rl_gpr_read_finish
  The execution order path is as follows:
    `RL_rl_dmi_req_cpu' -> `RL_rl_dmi_rsp_cpu'
  The relationships were introduced for the following reasons:
    (RL_rl_dmi_req_cpu, RL_rl_dmi_rsp_cpu)
    urgency order because of
    the following data dependency:
      [WillFire signal of rule/method `RL_rl_dmi_req_cpu',
       Enable signal of method `dm_dmi_read_addr' of submodule `core',
       Return value of method `RDY_dm_dmi_read_data' of submodule `core',
       CanFire signal of rule/method `RL_rl_dmi_rsp_cpu']
Verilog file created: Verilog_RTL/mkP2_Core.v
Elaborated Verilog module file created: build_dir/mkP2_Core.ba
All packages are up to date.
Warning: Unknown position: (S0080)
  10 warnings were suppressed.
INFO: Generated RTL into Verilog_RTL
cp  Verilog_RTL/*  xilinx_ip/hdl/
INFO: Copied RTL from  Verilog_RTL/  to  xilinx_ip/hdl/
